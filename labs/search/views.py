# This file contains the views for the search app.
# The views are responsible for rendering the search results and the search form.
# The search results are generated by querying the Judaicalink index.
# The search form is generated by the Vue.js framework.

import logging
import math
import pysolr
import re
from django.conf import settings
from django.core.cache.backends.base import DEFAULT_TIMEOUT
from django.shortcuts import render, redirect
from django.views.decorators.cache import cache_page

# see labs/urls.py def index to access root with http://localhost:8000
CACHE_TTL = getattr(settings, 'CACHE_TTL', DEFAULT_TIMEOUT)

# import SEARCH_URL from settings.py
SOLR_SERVER = settings.SOLR_SERVER.rstrip('/')
JUDAICALINK_INDEX = settings.JUDAICALINK_INDEX.lstrip('/')

# setup logging
logger = logging.getLogger('labs')

# SOLR Pooling
SOLR_SERVER = settings.SOLR_SERVER.rstrip('/')
SOLR_INDEX = settings.JUDAICALINK_INDEX.lstrip('/')
solr = pysolr.Solr(f"{SOLR_SERVER}/{SOLR_INDEX}", timeout=10, always_commit=False)


# error handling
def handle_error(request, template_name, log_message, exception=None):
    if exception:
        logger.error(f"{log_message}: {exception}")
    else:
        logger.error(log_message)
    return render(request, template_name)


# Usage in URL routing or within views
error_400 = lambda request, exception: handle_error(request, 'search/errors/400.html', "Error 400", exception)
error_404 = lambda request, exception: handle_error(request, 'search/errors/404.html', "Error 404", exception)
error_403 = lambda request, exception: handle_error(request, 'search/errors/403.html', "Error 403", exception)
error_500 = lambda request: handle_error(request, 'search/errors/500.html', "Error 500")


# Search index page
@cache_page(CACHE_TTL)
def index(request):
    """
    Renders the search index page.
    This page serves as the entry point for the search functionality.
    """
    return render(request, "search/search_index.html")


@cache_page(CACHE_TTL)
# All search navigation page
def all_search_nav(request):
    """
    Renders the search for all searches.
    """

    return render(request, "search/all_search_nav.html")


# Formats the results for display
def format_results(docs, highlighting):
    """
    Formats the search results for display in the search results page.
    :param docs: List of documents returned from Solr.
    :param highlighting: Dictionary containing highlighted fields for each document.
    :return: List of formatted results.
    """
    formatted = []
    for doc in docs:
        logger.debug(doc)
        result = {}
        doc_id = doc.get("id", "")
        for key in ['_version_', '_root_', '_text_', 'id', 'name_sort']:
            doc.pop(key, None)

        for key, value in doc.items():

            if key == "link":
                # Only show ID if it's a valid link
                result["Link"] = f"<a href='{value[0]}'>{value[0]}</a>" if value[0].startswith("http") else None
            elif key == "alternatives":
                # Format alternatives as an unordered list
                result["Alternatives"] = "".join(
                    f'<p class="text-dark">{alt}</p>' for alt in value  # if isinstance(value, list)
                )
            else:
                # Apply highlighting if available
                highlighted_value = highlighting.get(doc_id, {}).get(key, value)
                result[key.capitalize()] = " ".join(str(item) for item in highlighted_value) if isinstance(
                    highlighted_value, list) else str(highlighted_value)

        # Reorder fields: Name → Alternatives → Others → Link
        reordered_result = {}
        if "Name" in result:
            reordered_result["Name"] = result.pop("Name")
        if "Alternatives" in result:
            reordered_result["Alternatives"] = result.pop("Alternatives")
        reordered_result.update(result)  # Add remaining fields
        if "Link" in result:
            reordered_result["Link"] = result.pop("Link")  # Move Link to the end

        if "name_sort" in result:
            reordered_result.pop("name_sort")

        # remove all empty fields
        reordered_result = {key: value for key, value in reordered_result.items() if value is not None}

        formatted.append(reordered_result)
    return formatted


# Search results page
def search(request):
    """
    Handles the search request, constructs the query, and retrieves results from Solr.
    This function processes both simple and advanced search queries.
    :param request: The HTTP request object containing search parameters.
    :return: Rendered search results page with formatted results and pagination.
    """
    logger.debug("Searching...")
    alert = None

    if 'page' not in request.GET:
        params = request.GET.copy()
        params['page'] = '1'
        return redirect(f"{request.path}?{params.urlencode()}")

    # Get the raw query from the request
    search_term = request.GET.get("q", "").strip()
    # If the user didn’t enter anything, show an error instead of “match-all”

    if not search_term:
        # Render the *index* page again with an error message
        alert = "Please enter at least one search term."
        return render(request, "search/search_result.html",
                      context={
                          "alert": alert,
                          "search_input": "",
                      })

    # build the core query string
    query = build_advanced_query(search_term)

    # decompose simple AND‐filters into q + fq
    fq_list = []
    if " AND " in query and all(part.count(':') == 1 for part in query.split(" AND ")):
        parts = query.split(" AND ")
        query = parts[0]
        fq_list = parts[1:]

    logger.debug(f"Constructed Query: {query}")

    # Pagination and sorting parameters
    page = int(request.GET.get("page", 1))
    sort_order = request.GET.get("sort", "")  # Default: ascending
    rows_per_page = 20
    start = (page - 1) * rows_per_page
    sort = request.GET.get("sort")  # 'asc' or 'desc'

    # Construct Solr parameters
    solr_params = {
        "q": query,
        "q.op": "OR",
        "start": start,
        "rows": rows_per_page,
        "wt": "json",
        "hl": "true",
        "hl.fl": ["name", "Alternatives", "birthLocation", "deathLocation"],
        "timeAllowed": 2000,
        "hl.simple.pre": "<b>",
        "hl.simple.post": "</b>",
        "fl": "id,name,Alternatives,birthDate,birthLocation,deathDate,deathLocation,link",
    }

    if fq_list:
        solr_params["fq"] = fq_list  # 1. use fq for filters

    if sort in ("asc", "desc"):
        # use sort for ordering
        # TODO: use a more specific field for sorting, e.g., "name_sort" or "birthDate"
        solr_params["sort"] = f"score {sort}"

    try:
        response = solr.search(**solr_params)

    except pysolr.SolrError as e:
        logger.error(f"Solr query failed: {e}")
        # return the error page
        alert = "No results found, SOLR Connection error"
        return render(request, 'search/search_result.html', {"alert": alert})

    highlighting = response.highlighting
    formatted_results = format_results(response.docs, highlighting)

    # Calculate pagination
    total_hits = response.hits
    total_pages = math.ceil(total_hits / rows_per_page)
    pages = range(1, total_pages + 1)

    context = {
        'total_hits': total_hits,
        'ordered_dataset': formatted_results,
        'alert': alert or "No results found.",
        'current_page': page,
        'pages': pages,
        'sort_order': sort or "",
        'search_input': search_term,
    }
    return render(request, 'search/search_result.html', context)


def escape_query_chars(s: str) -> str:
    """
    Escape Lucene special characters so they don’t break your simple-term searches.
    """
    lucene_specials = r'+-!():^[]\"{}~*?|&\\/'
    return ''.join(f'\\{c}' if c in lucene_specials else c for c in s)


def build_advanced_query(raw: str) -> str:
    """
    Build a Solr query from ?q=… that:
      • If empty => returns "*:*"
      • If it contains ":", AND/OR/NOT, quotes or parentheses => passes it through raw
      • If it contains * or ? => OR‘s that wildcard across all fields
      • Otherwise => escapes the term and OR‘s it across all fields
      • Includes birthDate/deathDate when q looks like YYYY or YYYY-MM or YYYY-MM-DD
    :param raw: The raw search query string.
    :return: A Solr query string.
    """

    # strip out any stray HTML brackets against XSS attacks
    raw = re.sub(r"[<>]", "", raw)

    # 1) empty => match everything
    if not raw:
        return "*:*"

    # 2) collect your searchable fields
    # TODO: add Abstract, Publication and write all of them lowercase
    fields = ["name", "Alternatives", "birthLocation", "deathLocation", "link"]
    if re.match(r"^\d{4}(-\d{2}){0,2}$", raw):
        fields += ["birthDate", "deathDate"]

    # 3) advanced syntax: field:value, boolean, phrase or parens => hand off raw
    if (
            ":" in raw
            or re.search(r"\b(AND|OR|NOT)\b", raw, re.IGNORECASE)
            or '"' in raw
            or "(" in raw
            or ")" in raw
    ):
        return raw

    # 4) wildcard queries (“Ham*” or “?atz”) => search each field with that wildcard
    if "*" in raw or "?" in raw:
        return " OR ".join(f"{f}:{raw}" for f in fields)

    # 5) simple term => escape special chars and OR across all fields
    safe = escape_query_chars(raw)
    return " OR ".join(f"{f}:{safe}" for f in fields)
